"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[12149],{28453:(e,r,s)=>{s.d(r,{R:()=>i,x:()=>a});var t=s(96540);const n={},o=t.createContext(n);function i(e){const r=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),t.createElement(o.Provider,{value:r},e.children)}},41635:(e,r,s)=>{s.r(r),s.d(r,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"operator_transfers/transfers_poller_receiver","title":"Transfers Poller/Receiver","description":"conveyor-poller and conveyor-receiver are daemons responsible for tracking transfer status and updating it in the system.","source":"@site/../docs/operator_transfers/transfers_poller_receiver.md","sourceDirName":"operator_transfers","slug":"/operator_transfers/transfers_poller_receiver","permalink":"/documentation/operator_transfers/transfers_poller_receiver","draft":false,"unlisted":false,"editUrl":"https://github.com/rucio/documentation/tree/main/docs/../docs/operator_transfers/transfers_poller_receiver.md","tags":[],"version":"current","lastUpdatedBy":"Dimitris Xenakis","lastUpdatedAt":1747229898000,"frontMatter":{"id":"transfers_poller_receiver","title":"Transfers Poller/Receiver"},"sidebar":"docs","previous":{"title":"Transfers Overview","permalink":"/documentation/operator_transfers/transfers-overview"},"next":{"title":"Transfers Preparer","permalink":"/documentation/operator_transfers/transfers-preparer"}}');var n=s(74848),o=s(28453);const i={id:"transfers_poller_receiver",title:"Transfers Poller/Receiver"},a=void 0,c={},l=[{value:"Poller",id:"poller",level:2},{value:"Receiver",id:"receiver",level:2}];function d(e){const r={a:"a",blockquote:"blockquote",br:"br",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"conveyor-poller"})," and ",(0,n.jsx)(r.code,{children:"conveyor-receiver"})," are daemons responsible for tracking transfer status and updating it in the system.",(0,n.jsx)(r.br,{}),"\n",(0,n.jsx)(r.strong,{children:"You need to run one or both of them"})," depending on the transfer tool you are using:"]}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:["If you are using only FTS3, it is ",(0,n.jsx)(r.strong,{children:"recommended to use the receiver"})," for scalability. Although poller also works."]}),"\n",(0,n.jsx)(r.li,{children:"If you are using only Globus and/or BitTorrent, you only need to run the poller."}),"\n",(0,n.jsx)(r.li,{children:"If both FTS3 and Globus and/or BitTorrent, you need both receiver and poller."}),"\n"]}),"\n",(0,n.jsx)(r.h2,{id:"poller",children:"Poller"}),"\n",(0,n.jsxs)(r.p,{children:["The ",(0,n.jsx)(r.code,{children:"conveyor-poller"})," daemon periodically queries the transfer tools (such as FTS, Globus, or BitTorrent) directly to retrieve the status of ongoing transfers.",(0,n.jsx)(r.br,{}),"\n","Based on the results, it updates the state of each transfer in the system and/or refreshes the last access time.",(0,n.jsx)(r.br,{}),"\n","The transfer tool to query is taken from the transfer information internally and ",(0,n.jsx)(r.strong,{children:"no additional configuration is needed"}),"."]}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.strong,{children:"If using Globus or BitTorrent as the transfer tool, you need to use the poller."})}),"\n",(0,n.jsx)(r.h2,{id:"receiver",children:"Receiver"}),"\n",(0,n.jsxs)(r.p,{children:["The ",(0,n.jsx)(r.code,{children:"conveyor-receiver"})," daemon subscribes to an ActiveMQ message queue and continuously listens for transfer status updates.",(0,n.jsx)(r.br,{}),"\n","When it receives a message, it processes the update, changes the transfer's state accordingly, and/or updates the last access time."]}),"\n",(0,n.jsxs)(r.p,{children:["To set up FTS to send transfer status updates to ActiveMQ broker, see the instructions ",(0,n.jsx)(r.a,{href:"https://fts3-docs.web.cern.ch/fts3-docs/docs/messaging.html",children:"FTS3 Messaging Guide"}),"."]}),"\n",(0,n.jsxs)(r.blockquote,{children:["\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"Note:"})," The receiver connects to ActiveMQ using the ",(0,n.jsx)(r.strong,{children:"STOMP protocol"}),", so ensure your ActiveMQ instance has STOMP support enabled. As of this writing (May 2025), CERN FTS uses ",(0,n.jsx)(r.a,{href:"https://activemq.apache.org/components/classic/",children:"ActiveMQ-Classic"})," and\nnot tested with ",(0,n.jsx)(r.a,{href:"https://activemq.apache.org/components/artemis/",children:"ActiveMQ-Artemis"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(r.p,{children:["To configure ",(0,n.jsx)(r.code,{children:"conveyor-receiver"}),", your rucio server config i.e. ",(0,n.jsx)(r.code,{children:"rucio.cfg"}),", include the following section with described options:"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-cfg",children:"[messaging-fts3]\n# Set to True to use SSL with certificate/key authentication, or False to use username/password\nuse_ssl = True\n\n# A comma-separated list of ActiveMQ broker DNS hostnames or aliases\nbrokers = activemq1.example.org,activemq2.example.org\n\n# Only required if use_ssl = False\nusername = your-username\npassword = your-password\n\n# Port to use when NOT using SSL (i.e., use_ssl = False)\nnonssl_port = 61613\n\n# Port to use when using SSL (i.e., use_ssl = True)\nport = 61617\n\n# Required if use_ssl = True\nssl_key_file = /path/to/hostkey.pem\nssl_cert_file = /path/to/hostcert.pem\n\n# The message topic or queue where FTS publishes transfer status (complete) updates.\ndestination = /topic/transfer.fts_monitoring_complete\n\n# Optional: virtual host name used to connect to the broker\n# This is only needed if your ActiveMQ setup requires a virtual host (e.g., in multi-tenant environments)\nbroker_virtual_host = /atlas\n"})})]})}function u(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}}}]);