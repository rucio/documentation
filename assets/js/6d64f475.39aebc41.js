"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[29741],{815:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>r,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"operator/policy_packages/policy-package-algorithms","title":"Developing Policy Package algorithms","description":"A policy package can be used to define custom algorithms","source":"@site/../docs/operator/policy_packages/policy_package_algorithms.md","sourceDirName":"operator/policy_packages","slug":"/operator/policy_packages/policy-package-algorithms","permalink":"/documentation/operator/policy_packages/policy-package-algorithms","draft":false,"unlisted":false,"editUrl":"https://github.com/rucio/documentation/tree/main/docs/../docs/operator/policy_packages/policy_package_algorithms.md","tags":[],"version":"current","lastUpdatedBy":"dependabot[bot]","lastUpdatedAt":1749469449000,"frontMatter":{"id":"policy-package-algorithms","title":"Developing Policy Package algorithms"},"sidebar":"docs","previous":{"title":"Policy Packages Overview","permalink":"/documentation/operator/policy_packages/policy_packages_overview"},"next":{"title":"Developing a Policy Package","permalink":"/documentation/operator/policy_packages/policy-package-development"}}');var o=n(74848),a=n(28453);const s={id:"policy-package-algorithms",title:"Developing Policy Package algorithms"},c=void 0,r={},l=[{value:"Developing a custom algorithm",id:"developing-a-custom-algorithm",level:2},{value:"Registering a custom algorithm in your policy package",id:"registering-a-custom-algorithm-in-your-policy-package",level:2},{value:"lfn2pfn vs. non_deterministic_pfn algorithms",id:"lfn2pfn-vs-non_deterministic_pfn-algorithms",level:2}];function d(e){const i={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.p,{children:"A policy package can be used to define custom algorithms\nbased on core Rucio algorithms, in order to support custom logic."}),"\n",(0,o.jsx)(i.p,{children:"The current core algorithms are:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.a,{href:"https://github.com/rucio/rucio/blob/0d44febcfd5d0a773a24d60668177324c534bd18/lib/rucio/common/utils.py#L384",children:(0,o.jsx)(i.code,{children:"NonDeterministicPFNAlgorithms"})}),": Construct PFNs for non-deterministic RSEs"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.a,{href:"https://github.com/rucio/rucio/blob/0d44febcfd5d0a773a24d60668177324c534bd18/lib/rucio/core/rule.py#L96",children:(0,o.jsx)(i.code,{children:"AutoApprove"})}),": Handle automatic approval for replication rules"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.a,{href:"https://github.com/rucio/rucio/blob/0d44febcfd5d0a773a24d60668177324c534bd18/lib/rucio/common/utils.py#L546",children:(0,o.jsx)(i.code,{children:"ScopeExtractionAlgorithms"})}),": Extract scope from DID"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.a,{href:"https://github.com/rucio/rucio/blob/0d44febcfd5d0a773a24d60668177324c534bd18/lib/rucio/rse/translation.py#L31",children:(0,o.jsx)(i.code,{children:"RSEDeterministicScopeTranslation"})}),": Translate a PFN dictionary into a scope and name"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.a,{href:"https://github.com/rucio/rucio/blob/0d44febcfd5d0a773a24d60668177324c534bd18/lib/rucio/rse/translation.py#L102",children:(0,o.jsx)(i.code,{children:"RSEDeterministicTranslation"})}),": Translate an LFN to a path"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.a,{href:"https://github.com/rucio/rucio/blob/0d44febcfd5d0a773a24d60668177324c534bd18/lib/rucio/transfertool/fts3_plugins.py#L29",children:(0,o.jsx)(i.code,{children:"FTS3TapeMetadataPlugin"})}),": Add ",(0,o.jsx)(i.code,{children:"archive_metadata"})," to FTS transfers to ",(0,o.jsx)(i.code,{children:"TAPE"}),"."]}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"Most of these algorithms implement some default behaviour.\nIt is recommended to check this default behaviour to see\nif it is suitable for your needs; if it needs to be changed,\nplease see below for how to create custom algorithms."}),"\n",(0,o.jsxs)(i.p,{children:["For ",(0,o.jsx)(i.code,{children:"FTS3TapeMetadataPlugin"})," in particular,\nplease check the (FTS3 Transfertool Plugin documentation)[operator_transfers/configure_fts3_plugins.md]."]}),"\n",(0,o.jsx)(i.h2,{id:"developing-a-custom-algorithm",children:"Developing a custom algorithm"}),"\n",(0,o.jsx)(i.p,{children:"To develop a custom algorithm:"}),"\n",(0,o.jsxs)(i.ol,{children:["\n",(0,o.jsx)(i.li,{children:"Create a new class for your algorithm, subclassing the relevant core algorithm"}),"\n",(0,o.jsxs)(i.li,{children:["Register the custom algorithm with a name that is unique in relation to all other algorithms of that type\n(i.e. you cannot have two ",(0,o.jsx)(i.code,{children:"RSEDeterministicScopeTranslation"}),"-based algorithms with the same name,\nbut you can have a ",(0,o.jsx)(i.code,{children:"RSEDeterministicScopeTranslation"}),"-based algorithm and a ",(0,o.jsx)(i.code,{children:"ScopeExtractionAlgorithms"}),"-based algorithm\nwith the same name. In general, using your VO name should suffice.)"]}),"\n",(0,o.jsx)(i.li,{children:"Trigger registration of the algorithm by calling the relevant class method at the bottom of your file"}),"\n"]}),"\n",(0,o.jsxs)(i.p,{children:["As an example, this is the custom ",(0,o.jsx)(i.code,{children:"RSEDeterministicScopeTranslation"})," algorithm used in ATLAS:"]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:"class ATLASScopeExtractionAlgorithm(rucio.common.utils.ScopeExtractionAlgorithms):\n    def __init__(self) -> None:\n        \"\"\"\n        Initialises scope extraction algorithm object\n        \"\"\"\n        super().__init__()\n\n    @classmethod\n    def _module_init_(cls) -> None:\n        \"\"\"\n        Registers the included scope extraction algorithms\n        \"\"\"\n        cls.register('atlas', cls.extract_scope_atlas)\n\n    @staticmethod\n    def extract_scope_atlas(did: str, scopes: Optional['Sequence[str]']) -> 'Sequence[str]':\n        # Try to extract the scope from the DSN\n        if did.find(':') > -1:\n            if len(did.split(':')) > 2:\n                raise RucioException('Too many colons. Cannot extract scope and name')\n            scope, name = did.split(':')[0], did.split(':')[1]\n            if name.endswith('/'):\n                name = name[:-1]\n            return scope, name\n        else:\n            scope = did.split('.')[0]\n            if did.startswith('user') or did.startswith('group'):\n                scope = \".\".join(did.split('.')[0:2])\n            if did.endswith('/'):\n                did = did[:-1]\n            return scope, did\n\n\nATLASScopeExtractionAlgorithm._module_init_()\n"})}),"\n",(0,o.jsx)(i.h2,{id:"registering-a-custom-algorithm-in-your-policy-package",children:"Registering a custom algorithm in your policy package"}),"\n",(0,o.jsx)(i.p,{children:"The system for registering algorithms within policy packages is\nintended to be extensible so that new algorithm classes can be added\nrelatively easily. The basic workflow is as follows:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:["The ",(0,o.jsx)(i.code,{children:"get_algorithms"})," function within the policy package\nshould return a dictionary of functions of the new class, indexed\nby name"]}),"\n",(0,o.jsxs)(i.li,{children:["The core Rucio code should maintain a dictionary of functions of the\nnew class, ready to be called when required. The details of this\nwill differ depending on what the new class actually does and how it\nintegrates with the Rucio code, but typically the algorithm name to\nbe used will be selected by a value in the config file, as for the\ncurrent ",(0,o.jsx)(i.code,{children:"lfn2pfn"})," and ",(0,o.jsx)(i.code,{children:"non_deterministic_pfn"})," algorithm types."]}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"lfn2pfn-vs-non_deterministic_pfn-algorithms",children:"lfn2pfn vs. non_deterministic_pfn algorithms"}),"\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.code,{children:"lfn2pfn"})," algorithms and ",(0,o.jsx)(i.code,{children:"non_deterministic_pfn"})," algorithms are\nconceptually similar, but there are important differences between\nthem. Both produce a physical filename for use on an RSE, however\n",(0,o.jsx)(i.code,{children:"lfn2pfn"})," algorithms can only be used on deterministic RSEs - for\nexample, disk systems where the appropriate physical filename can be\nderived from the file's scope and name alone (as well as\nprotocol-specific information for the RSE in question).\n",(0,o.jsx)(i.code,{children:"non_deterministic_pfn"})," algorithms are used on non-deterministic\nRSEs (most often tape systems), and may use additional information\nabout the file (such as its metadata, any datasets that it is a part\nof, etc.) to construct the physical filename. Because files cannot\nbe uploaded directly to non-deterministic storage,\n",(0,o.jsx)(i.code,{children:"non_deterministic_pfn"})," algorithms are only ever called for\nreplications, but ",(0,o.jsx)(i.code,{children:"lfn2pfn"})," algorithms can also be called for\ninitial uploads."]}),"\n",(0,o.jsxs)(i.p,{children:["The ",(0,o.jsx)(i.code,{children:"lfn2pfn"})," algorithm to be used is determined by the\n",(0,o.jsx)(i.code,{children:"lfn2pfn_algorithm"})," attribute of the relevant RSE. If this is not set,\nthe ",(0,o.jsx)(i.code,{children:"lfn2pfn_algorithm_default"})," value from the ",(0,o.jsx)(i.code,{children:"[policy]"})," section of\nthe config file is used instead. The ",(0,o.jsx)(i.code,{children:"non_deterministic_pfn"})," algorithm\nto be used is determined by the ",(0,o.jsx)(i.code,{children:"naming_convention"})," attribute of the\nrelevant RSE."]})]})}function h(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,i,n)=>{n.d(i,{R:()=>s,x:()=>c});var t=n(96540);const o={},a=t.createContext(o);function s(e){const i=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(a.Provider,{value:i},e.children)}}}]);